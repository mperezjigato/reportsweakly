
# Week 2: REPORT

Since no specific tasks have been given this week, the intern has devoted his efforts towards the completion of tasks 3, 4 and 5, all set out during week 1. Whilst task 3 involves a long term objective (Ab Initio/MD codes) and is therefore **work in progress**, both tasks 4 (Markdown) and 5 (GitHub/Git) have been **completed**. A full description of the work carried out for all three tasks follows next. 

## Teaching material for Ab Initio and for Molecular Dynamics codes

Leaving aside all codes of interest not yet implemented on Genius, the full list of MD and quantum mechanical first-principles codes already implemented on the HPC is presented in tabular form, alongside information regarding on which of the software packages there has been progress: Information gathering, independent job testing, test suite run. Certainly, knowing that codes run fine for specific jobs is more than enough for most of our purposes. However, running a full battery of tests lets us make sure precision checks with respect to reference outputs, have been carried out (let alone the importance of comprehensive test suites for the intern to remember the full functionality of the packages). Since the *atomic simulation environment* enters both Ab Initio and MD categories (in fact having recently become a fully-fledged high-throughput computational materials science platform), we have decided to include it in this section. Moreover, the OpenMM Molecular Dynamics code is implemented in Genius as part the AlphaFold package, and since no specific module seems to exist with the name of the former, we have decided to include them both as a single item. Incidentally, we are not yet at the stage of providing any teaching material: The first step is to ascertain that the codes work.

![](tablesgenius.png)

## Learning Markdown

A sufficient number of documents has been written by the intern with Markdown, including weekly reports and the documents describing the exercises completed for task 5 (GitHub/Git): "definitive_day1.md", "definitive_day1contest.md" and "definitive_day2.md". The intern is slowly increasing the complexity of the Markdown documents (nested lists, images, tables, footnotes) as well as gathering information on (i) an existing online editor for quick typesetting (stackedit.io) and (ii) a Linux editor for conversion to high quality HTML/PDF documents (grip). For future reference, other aspects of Markdown worth looking into include templates/styles (dillinger and the kramdown converter) as well as scientific writing (authorea.com) and linting (markdownlint and markupsafe).

## Learning GitHub/Git

### "Day 1"

After attending a comprehensive training session on June 22, 2023 regarding GitHub/Git (a temporary repository "to_remove" with all the produced material was provided), the intern carried out the tutorial "hello_work" located at the GitHub website. During this exercise, and after the creation of a repository with the same name, all the png images corresponding to task2 (step-by-step description, in the form of screenshots, of the HPC application process at VSC-KU Leuven-ICTS) have been uploaded, therefore completing this part of the task. 

Once the training material "Version-control-with-git" had been studied by the intern, he carried out the first attempt to reproduce the most basic steps that lead to "to_remove", but this time on the repository "hello_world". As a matter of fact it was a really unfortunate attempt, as described on the document "definitive_day1.md". 

Firstly, the global configuration process failed as well as adding a private key. Instead of giving up, I continued by (wrongly) cloning two separate repositories, ie "hellow_world" and "to_remove". I then made the decision of copying the ```.gitignore``` file within "to_remove" to "hello_world", after which a stage/commit sequence followed. It must be noted that the commit step did indeed fail! (with an error message about the need to set up the global configuration!). 

At that point, I managed to properly set up the global configuration, after which I decided to edit and modify the ```README.md``` file within "hello_world". I then staged the modified file and proceeded to commit: This time it was successful. However, when I tried ``` $ git push```, the process via password did indeed fail!

### Corrections to the exercise "Day 1"

Following further discussions with GJB, he was able to identify the main mistake I incurred upon during the "Day 1" exercise: ==an SSH agent has to be set up==. Only after that step (see document "definitive_day1contest.md"), it is actually possible adding a private key on the local Linux system. Likewise, a second mistake was identified by GJB regarding the exercise "Day 1": The way had I set up the repository cloning step on the website was wrong (the SSH option must be chosen as opposed to the default HTTPS option; on the other hand, the address included in the ```git clone``` command must be that proposed by the website as opposed to the main repository website). Since I then had the global configuration properly set up, I was able to add a private key every day to my Linux account, and the cloning was properly set up and carried out, the pushes then worked fine.

### "Day 2"

After checking the notes taken by the intern regarding the GitHub/Git training session of June 23 and further studying the "Version-control-with-git" training material, the intern decided to ask GJB for clarification on aspects of branching. The response was to go through a full training session devoted to *branching*. The produced material was added to the already existing repository "to_remove". This section is a summary of the work carried out as described on the document "definitive_day2.md", which sets out to reproduce the steps of the training session devoted to *branching*. ==The full step-by-step procedure was in fact successfully reproduced afterwards==.

The diagram **main**$\rightarrow$**development**$\rightarrow$**feature** describes the structure of the exercise to be followed. In the first place, a new repository named "branchexercisepart1" was created (on the website) containing simply a ```README.md``` file. Once the private key had been added on the Linux system and the cloning process had been carried out, the ```README.md``` file had some simple modifications. Afterwards a stage/commit sequence was carried out, which was followed by ``` $ git push```. Note that up to this point, a single branch (main) is all that exists on both website and local Linux system.  

Locally on the Linux system, a new branch named "development" was then started from "main". Immediately, from "development", a new feature branch named ```feature/hello_world``` was started. I was inside the feature branch at that poing, whereby the work is to be done: (i) created a ```hello.f90``` Fortran file with a simple print statement, and (ii) created a simple makefile (named ```Makefile```) accordingly. Once I had compiled-linked and run the executable ```hello.exe``` successfully, I made the decision of creating/copying from a former repository a ```.gitignore``` file in order to avoid executables. Being still on the feature branch, and having then the ```.gitignore``` file alongside ```hello.f90```, ```Makefile``` and ```hello.exe```, I made the decision of carrying out a sequence stage/commit only for ```.gitignore```. I made then the decision of keeping (in the future) the ```.gitignore``` file on my "development" branch. I switched to "development" and carried out a push to origin of "development" (at this point, "development" only contained the ```README.md``` file).

Then, I switched back to feature and carried out a stage/commit sequence on both ```hello.f90``` and ```Makefile```. Immediately, I carried out a push to origin of the feature branch, and went to the website to set up a **feature**$\rightarrow$**development** Pull-Request (deleting at the end feature on the website). Afterwards, I locally switched to "development" and pulled "development" from Origin. From the "development" branch, I created a new feature branch named "feature/bye_world", after which I push(ed) the new branch (switching first) to Origin. Being on the new feature branch, I created a ```bye.f90``` file by modifying the previous ```hello.f90``` file: The print statement is now "bye_world". The makefile (```Makefile```, keeping the same name), is modified accordingly to compile-link ```bye.f90```. Once I hadd compiled, linked and run ```bye.exe```, a sequence stage(bye.f90)/commit (both bye.f90 and the modified Makefile, ie ``` $ git commit -a```) was carried out. Immediately, the feature branch ```feature/bye_world``` was pushed to Origin. Interestingly, the merging **feature**$\rightarrow$**development** was then carried out locally (previousy I had switched to "development"), instead of on the website (the ```feature/hello_world``` branch was merged onto development on the website!). I then got rid of both local feature branches, and later on of the remote ```feature/bye_world``` branch.

The very last few steps follow: (i) Pushed "development" to Origin (after switching to "development"), (ii) set up on the website a **development**$\rightarrow$**main** Pull-Request and carried out the merge (do not delete "development"), (iii) on the local Linux system switched to "main" and pulled "main" from origin, and (iv) switched back to "development".